// Generated by LiveScript 1.4.0
(function(){
  var borto, f;
  borto = window.borto = window.borto || {};
  borto.disc = {
    setPos: function(pos){
      this.pos = pos;
      return this.color = borto.modele.grille[this.pos];
    },
    goToDir: function(dir){
      var tab;
      tab = [this.pos];
      for (;;) {
        tab[tab.length] = tab[tab.length - 1] + dir;
        if (borto.modele.grille[tab[tab.length - 1]] != this.color) {
          break;
        }
        if (this.distance(tab[tab.length - 2], tab[tab.length - 1]) > 1) {
          break;
        }
      }
      return tab[tab.length - 2];
    },
    distance: function(d1, d2){
      return Math.abs(d1 % 7 - d2 % 7 || ~(d1 / 7) - ~(d2 / 7));
    }
  };
  f = bind$(borto.disc, 'goToDir');
  borto.modele = {
    isGameFinish: function(pos){
      var i$, ref$, len$, dir, res$, j$, to$, ridx$;
      if (pos < 0) {
        return false;
      }
      if (pos == null) {
        return this.isGameEnd;
      }
      if (typeof pos === 'boolean') {
        return this.isGameEnd = pos;
      } else {
        this.grille[-1] = null;
        borto.disc.setPos(pos);
        for (i$ = 0, len$ = (ref$ = [1, 6, 7, 8]).length; i$ < len$; ++i$) {
          dir = ref$[i$];
          res$ = [];
          for (j$ = f(-dir), to$ = f(dir); dir < 0 ? j$ >= to$ : j$ <= to$; j$ += dir) {
            ridx$ = j$;
            res$.push(ridx$);
          }
          this.winInfo = res$;
          this.isGameEnd = this.winInfo.length > 3;
          if (this.isGameEnd) {
            return true;
          }
        }
      }
    },
    play: function(pos, test){
      var i$;
      for (i$ = pos % 7; i$ <= 42; i$ += 7) {
        pos = i$;
        if (this.grille[pos + 7] != 0 && this.grille[pos] === 0) {
          this.mettrePion(pos, test);
          return pos;
        }
      }
      return -1;
    },
    mettrePion: function(position, test){
      var ref$;
      this.grille[position] = this.getPlayer();
      if (!test) {
        this.nextPlayer();
        (ref$ = this.backup)[ref$.length] = position;
      }
      this.isGameFinish(position);
      if (test) {
        this.grille[position] = 0;
      }
      return this.isGameFinish();
    },
    playAgain: function(){
      this.isGameFinish(false);
      this.init();
      this.setPlayer(1);
      this.play(3);
      return this.backup = [38];
    },
    joueur: 1,
    grille: [],
    backup: [],
    nextPlayer: function(){
      return this.player = this.player == 1 ? 2 : 1;
    },
    getPlayer: function(dec){
      dec == null && (dec = 0);
      return (dec + this.player) % 2 || 2;
    },
    setPlayer: function(number){
      return this.player = number;
    },
    isHumanTurn: function(){
      return this.player == 1;
    },
    undo: function(){
      var ref$, pos;
      this.isGameFinish(false);
      if ((ref$ = this.backup)[ref$.length - 1] != 38) {
        pos = this.backup.pop();
        this.grille[pos] = 0;
        this.nextPlayer();
      }
      return pos;
    },
    restore: function(backup){
      this.backup = backup;
      this.init();
      return this.setPlayer(this.backup.length % 2 ? 1 : 2);
    },
    init: function(){
      this.grille = repeatArray$([0], 42);
      return this.isGameFinish(false);
    },
    loadTab: function(tab, emplacement){
      return this.grille = this.modelToArray(tab);
    },
    setGrille: function(tab){
      return this.grille = tab;
    },
    setModel: function(tab){
      return this.setGrille(this.modelToArray(tab));
    },
    modelToArray: function(tab){
      var i$, len$, line, j$, len1$, disc, results$ = [];
      for (i$ = 0, len$ = tab.length; i$ < len$; ++i$) {
        line = tab[i$];
        for (j$ = 0, len1$ = line.length; j$ < len1$; ++j$) {
          disc = line[j$];
          results$.push(disc);
        }
      }
      return results$;
    }
  };
  borto.modele.init();
  window.Modele = borto.modele;
  function bind$(obj, key, target){
    return function(){ return (target || obj)[key].apply(obj, arguments) };
  }
  function repeatArray$(arr, n){
    for (var r = []; n > 0; (n >>= 1) && (arr = arr.concat(arr)))
      if (n & 1) r.push.apply(r, arr);
    return r;
  }
}).call(this);
