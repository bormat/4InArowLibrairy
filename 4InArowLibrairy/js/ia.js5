"use strict";
/* convention
 Array s to the end else never s they don't begin by uppercase
 Classes begin by upperCase
 private var of Class begin par $ 
*/
var forOf =function(obj, func){
	var keys  = Object.keys(obj);
	var lg = keys.length
	for (var i = 0; i < lg; i++){
			var o = keys[i];
			func(obj[o], o, obj);     
	}
}
var forOfSome = function(obj, func){
	var keys  = Object.keys(obj);
	var lg = keys.length;
	for (var i = 0; i < lg; i++){
		var o = keys[i];
		if (func(obj[o], o, obj)){
			return;
		};     
	}
	return true;//all funcs return false we return true
}
var IA = window.IA = {
		dif:100,
		setDif:function(dif){
			IA.dif=dif;
		},
			//ne pas Modele.play dessous un endroit ou on gagnerais en jouant au dessus 
	notUnderMe : function(inadvisables){
		// ne pas Modele.play dessous un endroit ou l'on gagne 
		for ( var i = 0;i<7;i++){
			Modele.nextPlayer();
			var position=Modele.play(i,true);
			//on la mit en fictif avec le parametre true  mais il faut qu'il reste dans la Modele.grille 
			Modele.grille[position]="2";		
			Modele.nextPlayer();
			Modele.play(i,true);
			//supprimer le pion rajouté précédemment 
			Modele.grille[position]="0";		
			if (Modele.isGameFinish()){
				//rajouter la position en déconseillé 
				if (position !=inadvisables.at(-1) && position >=0)				
				{
						if (position >=0){
							inadvisables.push(position);
						}
				}
			}				
		}

	},

	//retourne ou Modele.play sinon -1
	ifPlayHereGiveMeExactPos : function(posJoueur){
		posJoueur=parseInt(posJoueur);
		posJoueur=Modele.play(posJoueur,true);
		if (~posJoueur){
			var cond1 = ~IA.forbids.indexOf(posJoueur) ;
			var cond2 = ~IA.inadvisables.indexOf(posJoueur);
			if (!(cond1 || cond2)){
				IA.isModelfound = true
				posJoueur = Modele.play(posJoueur,true);
				IA.pos = posJoueur;
				return(posJoueur);
			}
		}
		return(IA.pos = -1);
	},
	positionOfSym : function(pos,length,sym){
		return pos += sym && mod(length + ~pos, 7) - pos%7 ;
	},
	fillsWinningPos : function (){
	//initialiser les 2 tableaux -1 = pas de position gagnante sur cette colonne sinon c'est la position 

		for(var o=0; o<7 ;o++){
			IA.winningYellowPairs[o]= -1;
			IA.winningRedPairs[o]= -1;
			IA.winningYellowOdds[o]= -1;
			IA.winningRedOdds[o]= -1;
		}

		for(var o=42; o>0; o--){
			if ( Modele.grille[o]==0 ){
				Modele.grille[o]=1;
				var trouvePlayerImpaire=IA.winningYellowOdds[o%7];
				var trouveBotPaire=IA.winningRedPairs[o%7];
				var trouvePlayerPaire=IA.winningYellowPairs[o%7];
				var trouveBotImpaire=IA.winningRedOdds[o%7];

				if ( Math.floor(o/7)%2==1 && trouvePlayerImpaire== -1 && Modele.isGameFinish(o)){				
					IA.winningYellowOdds[o%7]=o;
				}
				else if ( Math.floor(o/7)%2==0 && trouvePlayerPaire== -1 && Modele.isGameFinish(o)){				
					IA.winningYellowPairs[o%7]=o;
				}
				
				Modele.grille[o]=2;
				if ( (Math.floor(o/7)%2)==0 && trouveBotPaire==-1 && Modele.isGameFinish(o)){
					IA.winningRedPairs[o%7]=o;
				}
				else if ( (Math.floor(o/7)%2)==1 && trouveBotImpaire==-1 && Modele.isGameFinish(o)){
					IA.winningRedOdds[o%7]=o;
				}
				Modele.grille[o]=0;

			}
		}		
	},
	playAllPos: function(u){
		IA.pos=-1;
		for (var i=u-7;i < u && IA.pos < 0 ;i++  ){
			IA.ifPlayHereGiveMeExactPos(i);
		}		
	},
	playWithoutModel : function(){
		var firstTurn = true;
		loop1:do {
			IA.playAllPos(IA.posJoueur);
			if (~IA.pos && firstTurn){//si une position est jouable
				do{//ttque qu'une position est jouable on interdit celles qui amenent au badmodel
					if(!IA.wontBecomeLikeThisModel(TabWontBecomeLikeThisModelPlayerTurn, 1, IA.pos)){
						break loop1;
					}	
					IA.playAllPos(IA.posJoueur);
				}while (~IA.pos);
				firstTurn = false;
			}
		}while((IA.inadvisables.pop() != null  || IA.forbids.pop() != null )&& IA.pos<0);	
	}
		,
		boolSmart:[],
		isModelfound:function(){
			return IA.isModelfound;
		},
		winInTwoTurn : function(playerTurn){
			for(var i=0;i<7;i++){
				Modele.setPlayer(playerTurn);
				IA.pos=Modele.play(i,true);
				if ( playerTurn==1 ? IA.forbids.indexOf(IA.pos) < 0 : !IA.comparerLigne("g",IA.pos-7)){
					var position2=IA.pos;
					Modele.grille[IA.pos]=playerTurn;
					var cptGagnerDirect=0;
					for(var o=0;o<7;o++){
						IA.pos = Modele.play(o,true);
						if (Modele.isGameFinish() && ~IA.pos){
							cptGagnerDirect++;
							//si il y a une position gagnante au dessus d'une autre 
							var WinnerPos= Modele.getPlayer() == 1 ? "g" : "i";
							var otherPlayerWinOnMe=(Modele.getPlayer() == 1) ? false: IA.comparerLigne("g",IA.pos);
							if ( (cptGagnerDirect == 1 && IA.comparerLigne(WinnerPos,IA.pos-7) )|| (cptGagnerDirect >1 && !otherPlayerWinOnMe) ){	
								Modele.grille[position2] = 0;
								IA.pos = i;
								IA.isModelfound = true;
								return(i);
							}
						}
					}
					Modele.grille[position2]=0;
				}
			}
			return IA.pos = -1;
		},
		gagnerDirect : function(){
			for ( var i = 8; --i;){
				IA.pos = Modele.play(i,true);
				if (Modele.isGameFinish()){
						Modele.isGameFinish(false);
						return IA.isModelfound = true;
				}
			}
			IA.pos=-1;
		},
		playAvecModele  : function(){
				var param= {modelID:0};
				var j = 0;
				IA.pos5 = 48;
				IA.modelId = 0;
				var pos2 = function rec(){
					var TabOfTab=[attaque,defense,miniDef,mesModele]
					for(;j < TabOfTab.length;j++ ){
						while (1){
							if(!(IA.modelId < TabOfTab[j].length)){
								break;
							}
							var position3 = IA.modeledetectorAndAnswer(TabOfTab[j]) ;
							IA.modelId/*=param.modelID*/;
							if ( ~position3){
								IA.ifPlayHereGiveMeExactPos(position3);
								if (~IA.pos){
									var isPosBad = IA.wontBecomeLikeThisModel(TabWontBecomeLikeThisModelPlayerTurn, 1, IA.pos);
									if(isPosBad){
										rec();
									}
									return IA.pos;
								}
								IA.pos5--;
							}
							IA.modelId = param.modelID = ++IA.modelId;
						}
						IA.modelId = param.modelID = 0;
						IA.pos5 = 48;
					}
					IA.pos5 ="notFound";
					return -1;
				}();
				return pos2;
			},
		falseOrModelIfFound : function (param){
	if (param.isModelfound){
		return param;
	}
	return false;
}	,

giveMeACheckedPosition:function(functionWhoReturnFalseOrPosToCheck){
		var i=0;
		var param ={isModelfound:false}
		do{
			IA.pos = functionWhoReturnFalseOrPosToCheck();
			if(IA.pos < 0){
				IA.isModelfound=false;
				break;
			}
			param = IA.wontBecomeLikeThisModel(TabWontBecomeLikeThisModelPlayerTurn, 1, IA.pos);
			IA.isModelfound = !param.isModelfound;
		} while(i++,param.isModelfound && i<7);
	},
	wontBecomeLikeThisModel : function(TabWontBecomeLikeThisModel, player, posBot){
	if(posBot<0){return {}}
		
	var param;
	posBot = Modele.play(posBot,true);
	Modele.grille[posBot]  = player;
    for (var i=0; i<7  ;i++){
		var pos=Modele.play(i,true);
		Modele.grille[pos]=2;
		if (~pos){
			IA.isModelfound = ! forOfSome(TabWontBecomeLikeThisModel, function(mod){
				param= IA.structModelDetector(mod, 48) ;
				if (param.isModelfound){
					return true;
				}
			})
			Modele.grille[pos]=0;
			if (IA.isModelfound){
				IA.inadvisables.push(parseInt(posBot))
				break;
			};
		}
	}
	Modele.grille[posBot]=0;
	pos= param.isModelfound ? -1 : pos;
	return param;
},futureIWant:function(param,ModelInStruct,pos){
	for (var j=0; j<7 && !param.isModelfound; j++){
		var pos3 = Modele.play(j,true);
		if (~pos3){
			Modele.grille[pos3]=1;
			param=IA.findModel(ModelInStruct ,pos);
			Modele.grille[pos3]=0;
		}
	}
	if (param.isModelfound){
		IA.currMod = ModelInStruct.tab;
		IA.playAt = pos3;
	}
	IA.isModelfound = param.isModelfound;
	return param;
},
	modeledetectorAndAnswer: function (modele,findAt){
		if (findAt){
			IA.modelId = 0;
		}else{
			var findAt = {};
		}
		IA.modele=modele;
		IA.param={isModelfound:false};
		var tab=[];
		while ( IA.modelId < modele.length && IA.param.isModelfound==false){
			tab = IA.getListOfMatchingPos(findAt);	
			findAt.modelID++;
			IA.modelId = findAt.modelID;
		}
		IA.pos = tab[0];
		findAt.modelID--;
		IA.modelId--;
		IA.isModelfound=IA.param.isModelfound;
		return IA.pos = !IA.isModelfound ? -1 : IA.pos;
	},
findModel:function(ModelInStruct ,pos){
			var param ={}
			IA.currMod = ModelInStruct.tab;
			IA.isModelfound=false;
			if( !ModelInStruct.hasOwnProperty("logicalOperator") ){
				forOfSome(IA.currMod, function(mod){
					param=IA.modeleDetector3(mod, pos);
					if ( param.isModelfound ){
						return true;
					}
				})
			}else{// by default it is the operator or between Model else do the next code
				var otherOption={}
				var length=(ModelInStruct.hasOwnProperty("sym")) ? 1 : 2 ;
				for (var j=0;j<length && IA.isModelfound===false; j++){
					if (ModelInStruct.hasOwnProperty("sameSym") && length == 2){
						otherOption.sym=Boolean(j);
					}
					var stringToEVal="param=";
					var logicalOperator = ModelInStruct.logicalOperator;
					for (var i=0; i<logicalOperator.length-1; i++){
							stringToEVal+=logicalOperator[i]+" IA.falseOrModelIfFound(IA.modeleDetector3(ModelInStruct.tab["+i+"],pos,otherOption)) ";
					}
					stringToEVal+=logicalOperator[i];
					eval(stringToEVal);
					IA.isModelfound=param.isModelfound;
				}
			}
			IA.currMod = ModelInStruct.tab;
			return param ;
		},
		structModelDetector : function (ModelInStruct,pos){
	var param = {};
	IA.currMod = ModelInStruct.theTab;
	param = IA.findModel(ModelInStruct ,pos);
	//if we can reach a futur model that is not already reached
	if(ModelInStruct.mode == "futur" ){
		param = param.isModelfound ? {isModelfound:false} : IA.futureIWant(param,ModelInStruct,pos);
	}
	//watch exeptions if model found
	if (param.isModelfound){
		var exept = ModelInStruct.exept;
		param.theModelISelf = ModelInStruct;
		if(exept){
			exept.sym = param.sym;
			if(IA.structModelDetector(exept, 48).isModelfound){
				param.isModelfound=false;
			}
		}
		if(ModelInStruct.hasOwnProperty("playAt")){
			IA.playAt =  ModelInStruct.playAt;
		}
	}
	IA.isModelfound = param.isModelfound;
	return param;
},
	

	//fcomparerCaractere
	//5 peu importe et
	//1 pour j1 et 2 pour j2 0 pour vide 
	//3 pour un j1 en paire 4 pour un j1 en impaire 
	//6 pas de 0 mais la position doit exister
	//7 pour j2 en paire et 8 pour j2 en impaire 
	//9 pas de 0 renvoie true si la position n'existe pas
	//g indique une position gagnante en mettant un pion adverse à cette position 
 comparerCaractere: function(carMod,car,impaire){	
	car+="";
	var a =carMod +"" ;
	return (
		impaire && a == 8 && car == 2 || impaire && a == 4 && car == 1 
	)||(
		!impaire && (car == 1 && a ==3 || (a ==7 && car == 2) )
	)||(
		car == a
	)||(
		a =='a'
	)||(
		a =='y' && car != 2
	)||(
		a =='z' && car !=1
	)||(
		a =='9' && car !=0
	)||(
		carMod =='6' && ["1","2"].has(car)
	)||(
		carMod =='5' && ["1","2","0"].has(car)
	);			
},


	bloquerDirect: function  (){
	//cherche un endroit ou l'adversaire gagne pour le bloquer 
		Modele.nextPlayer();
		for ( var i = 0;i<7;i++){
			IA.pos = Modele.play(i,true);
			if (Modele.isGameFinish()){
					Modele.nextPlayer();
					return IA.pos=Modele.play(IA.pos,true);
			}		
		}
		Modele.nextPlayer();
		IA.pos = -1;
	}
	//remplit $forbids
	 ,dontHelpJ2 : function($forbids){
		for ( var i = 0;i<7;i++)
		{
			var position=Modele.play(i,true);
			//on la mit en fictif avec le parametre true  mais il faut qu'il reste dans la Modele.grille 
			Modele.grille[position]="1";
			Modele.nextPlayer();
			Modele.play(i,true);
			Modele.nextPlayer();
			//supprimer le pion rajouté précédemment 
			Modele.grille[position]="0";

			if (Modele.isGameFinish() && position !=$forbids[$forbids.length-1] && position >= 0)
			{
					$forbids.push(position);
			}		
		}
	},
//push where don't play without modele
detectBadPositionAlgorythme:function(){
	for (var i=0;i<7;i++){
		Modele.setPlayer(1);
		var pos = Modele.play(i,true);
		Modele.grille[pos]="1";
		if (~IA.winInTwoTurn(2)){
			IA.inadvisables.push(pos);
		}
		IA.isModelfound = false;
		Modele.grille[pos]=0;
	}
	Modele.setPlayer(1);
},
	
	getListOfMatchingPos:function(findAt){
		var tabPosInBigGrille=[];
		//on cherche le modele
		var model = IA.modele[findAt.modelID = IA.modelId]
		IA.param = IA.structModelDetector(model, IA.pos5);
		IA.currMod = IA.param.theTab;
		IA.pos = IA.param.pos;
		if(IA.currMod){
			IA.currMod  = (Array.isArray(IA.currMod[0]) ? IA.currMod[0] : IA.currMod);
		}
		//si trouvé 
		if ( IA.isModelfound==true ){			
			if (Array.isArray(IA.playAt)){
				for (var u=0;u<IA.playAt.length ;u++){	
					tabPosInBigGrille.push(IA.addPosOkToGroup(IA.playAt[u]))
				}
			}else{
				tabPosInBigGrille.push(IA.addPosOkToGroup(IA.playAt));
			}
			IA.pos5=IA.beginToEnd(IA.pos);
		}else{//si pas trouvé 
			IA.pos5 = 48;
		}
		return tabPosInBigGrille;
	},
	
	addPosOkToGroup : function (posRelativeToModele){
		if( IA.param.theModelISelf && IA.param.theModelISelf.mode == "futur"){
			return IA.playAt;
		}else{
			return IA.pos + IA.positionOfSym(posRelativeToModele,IA.currMod[0].length, IA.param.sym);
		}
	},
			
	beginToEnd:function(begin){
		return begin + IA.currMod.length*7-7;
	},
		findForbiddenAndNotRecommandedPosition : function (){
		IA.forbids.length = IA.inadvisables.length = 0;
		IA.dontHelpJ2(IA.forbids);
		IA.detectBadPositionAlgorythme();
		var findAt = {};
		IA.pos5 = 48;
		IA.param={isModelfound:false};
		var tabForbids=[modPosDeconseille,interditUnPeu];
		for ( var o=0 ; o < tabForbids.length ;o++){
			IA.modele=tabForbids[o];
			IA.modelId = 0;
			while (IA.modelId< IA.modele.length ){
				//tant que le modele est trouvé on continue de le chercher et de pusher les positions interdites 
				var tab = IA.getListOfMatchingPos(findAt);
				if (IA.param.isModelfound==false ){
					IA.pos5 = 48;
					IA.modelId++;

				}else{
					Array.prototype.push.apply(IA.inadvisables, tab)
					IA.pos5--;
				}
			}
		}
		IA.notUnderMe(IA.inadvisables);
		IA.DeleteException();	
	},


	 DeleteException:function(){
		var findAt={}
		IA.modelId = 0;
		IA.pos5 = 48;
		while(IA.modelId  < mesModele.length){
			IA.modeledetectorAndAnswer(tabException);
			if (~IA.pos){
				var position = IA.pos;
				var pos= IA.inadvisables.indexOf(position)
				while ( ~pos ){
					IA.inadvisables.splice(pos,1);
					pos= IA.inadvisables.indexOf(position)
				}	
				IA.pos5--;
			}
			else
			{
				break;
			}
		}
	},

	 isModeleBottomFlat:function(oneModele){
		return forOfSome(oneModele.at(-1), function(pos){
			if (pos!='a' && pos!='9'){
				return true;
			}
		}) 
	},
	 modeleDetector4:function(oneModeleAndTheAnswer,position){
		var r=IA.modeleDetector3(oneModeleAndTheAnswer[0],position)
		IA.pos = r.pos;
		IA.playAt = oneModeleAndTheAnswer[1];
		IA.currMod = oneModeleAndTheAnswer[0];
		if(!r.isModelfound){
			IA.pos = -1;
		}
		return r;
	},
	 modeleDetector3:function(oneModele,position,otherOption){
		var sym=true;
		var dontChangeSym=false;
		var otherOption = otherOption || {}
		if (otherOption.hasOwnProperty("sym")){
			sym=otherOption.sym
			dontChangeSym=true;
		}
		var posOneModeleSym2={ true:{pos:position}, false:{pos:position} };
		var stopLoopCond=function(){
			var posSym = posOneModeleSym2[sym].pos
			var pos = posOneModeleSym2[!sym].pos
			return (posOneModeleSym2[sym].isModelfound || otherOption.hasOwnProperty("samepos") 
					|| (posSym < 0  && pos < 0)  || (dontChangeSym && posSym < 0));
		}
		do {
			var poses = posOneModeleSym2[sym]=IA.modeleDectector1(oneModele,posOneModeleSym2[sym].pos,sym);
			if (!poses.isModelfound ){
				//if we haven't the place to find the model at this pos go back until we have the place
				poses.pos = Math.min(Math.ceil(poses.pos/7)*7 - oneModele[0].length, poses.pos-1);
				sym= !dontChangeSym && !sym;
			}
		} while( !stopLoopCond() );
		IA.isModelfound = posOneModeleSym2[sym].isModelfound;
		//IA.currMod = oneModele;
		return { pos: posOneModeleSym2[sym].pos-7*(oneModele.length-1), sym:sym, isModelfound: IA.isModelfound, theTab:oneModele};
	},

	
	modeleDectector1 : function(oneModele,posOneModele,sym){
		if ( posOneModele !==false ){
			for (var i = 0; i++ < oneModele.length ;){//i from 1 to lenght
				var line= oneModele.at(-i);
				if (sym){ 
					line = line.reverse();
				}
				if (!IA.comparerLigne(line,posOneModele-7*(i-1))){
					break;
				}				
			}
			if (i > oneModele.length){//if model found
				return { pos:posOneModele, isModelfound:true };
			}
		}
		return { pos: posOneModele, isModelfound:false }; 
	},
	
	 topToBottom : function(pos, length){
		return ( pos + length*7 -7 )
	},
	
	 bottomToTop : function(pos, length){
		return ( pos + ~length * 7 )
	},
	comparerLigne : function(modligne,o) 
	{
		if (o <0) return false;
		var cont= true
		for (var i=o;i< modligne.length + o  && cont;i++){
				var a=modligne.charAt(i - o);
				var a=""+a;
				var b=Modele.grille[i];	
				if (o <0) return false;
				var impaire=Math.floor(i/7)%2;
				if (Modele.grille[i]==0 )
				{	
					var gotonextif=false;
					switch(a)
					{
						case 'q':case 'p':						
								cont = IA.winningRedPairs[i%7] < IA.winningYellowOdds[i%7];
								if (a =='p') cont = !cont  ;
								break;
						case 'e': case 'r': case 'w':
								cont = IA.winningRedPairs[i%7] < IA.winningYellowOdds[i%7]|| IA.winningYellowOdds[i%7]==-1;
								//ne pas prendre en compte les pairs au dessus de la position 
								cont= cont && ((IA.winningRedPairs[i%7]<=i));
								if (a == 'w') cont =!cont ;
								if (a !='r')break;							
						case 'g':case 'j':case '.':case 'f':
								Modele.grille[i]=1;
								cont= cont && Modele.isGameFinish(i);
								if (a == 'j' || a == '.')cont = !cont;
								if (a !='.' && a !='f' ||  !cont){
									break;
								}
						case 'h':case 'i':
								Modele.grille[i]=2;
								cont = (Modele.isGameFinish(i));
								if (a == 'h' || a =='f')cont = !cont;
								break;
						case 't':
								cont = (IA.inadvisables.indexOf(i)+1);
								break;					
						default:							
								var gotonextif=true; 
					}
					Modele.grille[i]=0;
				}
				if (Modele.grille[i]!=0 || gotonextif)
				{
					cont = (IA.comparerCaractere( a,b,impaire));
				}
				
				if (( cont) && (i >  modligne.length - 2 + o  ))
				{
							//return if line are equals 
							return 	cont
				}
		}
	
	

	},
	p4BlockEasy:function(posJoueur,retournerPosition){
		IA.posJoueur = posJoueur;
		var findAt,botSmart;
		if (Modele.isGameFinish()){
				return(false);
		};
		if (parseInt(IA.dif)/100+Math.random() > 1){//dif is choose by player with slider
			IA.boolSmart.push("true")//play smartly
			Modele.setPlayer(1);
			IA.fillsWinningPos();
			IA.isModelfound = false;
			IA.pos=-1;
			IA.modelId=0;
			findAt={modelID:0};
			IA.pos5 = 48;
			[
	/*0*/		IA.gagnerDirect,											
	/*1*/		IA.bloquerDirect,											
	/*2*/		IA.findForbiddenAndNotRecommandedPosition,
				IA.winInTwoTurn.bind(IA, 1),
	/*3*/		IA.modeledetectorAndAnswer.bind(IA, perfectModele,{modelID:0}),
	/*4*/		function(){
					IA.modelId=0;
					IA.pos5 = 48;
					IA.playAvecModele();
				},											
	/*5*/		IA.playWithoutModel.bind(IA, posJoueur)					
			].some(function(func,i){//i pour debug
				func();
				return ~IA.pos;
			})
		}else{
			//push that we don't play in 100% mode  and take a pos randomly
			IA.boolSmart.push("false");
			IA.pos=Math.floor(Math.random()*7);
		};	
		return Modele.play(IA.pos,retournerPosition);
	},
	winningRedPairs : [],
	winningYellowOdds : [],
	winningRedOdds : [],
	winningYellowPairs:[],	
	forbids:[],
	inadvisables:[],
	isModelfound : false,
	pos:-1,
	modelId : 0,
}	

	/*pos5;
	modele;
	playAt;
	param;
	currMod;*/
	//current modele
	//posJoueur derniere position Modele.play 
	//si retournerPosition on ne joue pas dans la Modele.grille mais retoune la position ou Modele.play parametre parfait pour les tests TDD













	
	//remplit la position gagnante la plus basse en pair pour le j2 rouge et et impaire pour le j1 jaune 
	

}();
	
	
	Array.prototype.has = function(variable){
		return ~this.indexOf(variable);
	}